## 接口

接口用来描述类具有的功能，而并不给出每个功能的具体实现。

接口中的方法自动为public abstract。接口中的域被自动设置为public static final。（为了防止）

接口不提供实例域，在Java SE8之前，也不提供方法。

实现接口的关键字为implement。

接口不是类，不能使用new实例化一个接口。但是可以声明接口变量，然后引入一个实现了接口的类对象。

可以使用instance检查一个对象是否实现了某个特定的接口。

### Java SE 8 中的静态方法和默认方法

#### 默认方法

Java 8 允许给接口添加一个非抽象的方法实现，只需要使用**default**关键字即可，这个特征又叫做扩展方法（也称为默认方法或虚拟扩展方法或防护方法）。在实现该接口时，该默认扩展方法在子类上可以直接使用，它的使用方式类似于抽象类中非抽象成员方法。

默认方法允许我们在接口里添加新的方法，而不会破坏实现这个接口的已有类的兼容性，也就是说**不会强迫实现接口的类实现默认方法**。

默认方法和抽象方法的区别是抽象方法必须要被实现，默认方法不是。作为替代方式，接口可以提供一个默认的方法实现，所有这个接口的实现类都会通过继承得到这个方法（如果有需要也可以重写这个方法）。

```
interface Defaulable {
    //使用default关键字声明了一个默认方法
     @SuppressLint("NewApi")
     default String myDefalutMethod() {
        return "Default implementation";
    }
}
class DefaultableImpl implements Defaulable {
    //DefaultableImpl实现了Defaulable接口，没有对默认方法做任何修改
}
class OverridableImpl implements Defaulable {
        //OverridableImpl实现了Defaulable接口重写接口的默认实现，提供了自己的实现方法。
        @Override
        public String myDefalutMethod() {
            return "Overridden implementation";
        }
}
```

##### 默认方法冲突

如果先在接口中将一个方法定义为默认方法，然后又在超类或另一个接口定义了同样的方法，则规则如下：

1、超类优先。如果超类提供了一个具体的方法，同名且有相同参数类型的默认方法会被忽略。

2、接口冲突。如果一个超接口中提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不管是否为默认方法）相同的方法，必须覆盖这个方法来解决冲突。（二选一）

>当然，如果两个接口都没有为共享方法提供默认实现， 那么就与 Java SE 8之前的情况一样，这里不存在冲突。 实现类可以有两个选择：实现这个方法，或者干脆不实现。如果是后一种情况，这个类本身就是抽象的。

如果一个类扩展了另一个类，且同时实现了一个接口，并且从超类和接口继承了相同的方法，在这种情况下，只会考虑超类的方法，接口的**所有默认方法**都会被忽略。这正是“类优先”规则。

**优点**

可以在不破坏代码的前提下扩展原有库的功能。但从另一个方面来说，这使得接口作为协议，类作为具体实现的界限开始变得有点模糊。优点是，它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。

#### 静态方法

java8中为接口新增了一项功能：定义一个或者更多个静态方法。类似于类中的静态方法，接口定义的静态方法可以独立于任何对象调用。所以，在调用静态方法时，不需要实现接口，也不需要接口的实例，也就是说和调用类的静态方法的方式类似。语法如：接口名字.静态方法名。

#### 其他

为什么不能用默认方法来重载equals，hashCode和toString？

接口不能提供对Object类的任何方法的默认实现。从接口里不能提供对equals，hashCode或toString的默认实现。因为若可以会很难确定什么时候该调用接口默认的方法。

如果一个类实现了一个方法，那总是优先于默认的实现的。一旦所有接口的实例都是Object的子类，所有接口实例都已经有对equals/hashCode/toString等方法非默认 实现。因此，一个在接口上的这些默认方法都是没用的，它也不会被编译。（简单地讲，每一个java类都是Object的子类，也都继承了它类中的equals/hashCode/toString方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。）



**java 8中抽象类与接口的异同**

相同点：

1）都是抽象类型；

2）都可以有实现方法（以前接口不行）；

3）都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）

不同点：

1）抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；

2）抽象类和接口所反映出的设计理念不同。其实抽象类表示的是"is-a"关系，接口表示的是"like-a"关系；

3）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。

Note：friendly 型：如果一个类、类属变量及方法不以public,protected,private这三种修饰符来修饰，它就是friendly类型的，那么包内的任何类都可以访问它，而包外的任何类都不能访问它(包括包外继承了此类的子类)，因此，这种类、类属变量及方法对包内的其他类是友好的，开放的，而对包外的其他类是关闭的。

## lambda表达式

lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。

lambda表达式形式：(参数)->{表达式}。例如：

(String a,String b)->{

if(a.length()<b.length()) return -1;

else if(a.length()>b.length()) return 1;

else return 0;

}

>即使表达式没有参数，仍要提供空括号，无需指定表达式的返回值类型，lambda表达式的类型会由上下文推导得出。如果可以推导出lambda表达式参数类型，则可以在写表达式的时候不写其类型。

>如果一个 lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值，这是不合法的。例如，（int x)-> { if(x >= 0) return 1; } 就是不合法的。

对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为**函数式接口**。

例如Arrays.sort方法。第二个参数需要一个Comparator实例，Comparator就是只有一个方法的接口，所以可以提供一个lambda表达式：

Array.sort(words,(a,b)->a.length() - b.length());

**暂缺其他的，感觉代码很方便，但是影响阅读**
