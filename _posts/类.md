## 类之间的关系

1、**依赖**（uses-a）：在定义类时如果一个类的改动会引起另外一个类的变动，则称两个类之间存在依赖关系。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。

2、**聚合**（has-a）：一个类包含另一个类。有整体与局部的关系，比如说球队和球员。（xx是yy的一部分）

3、**组合**（contains-a）：，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了。（更严格的聚合关系）

4、**关联**：用于表示一类对象与另一类对象之间有联系，通常是属性的存在。映射到代码中，就是一个类中的方法中存在另一个类的对象。关联关系还有以下分类（ 注：关联关系中作为成员变量的类一般会在类中赋值  ）：

 双向关联：默认情况下，关联是双向的。比如说顾客和购买的商品，顾客拥有商品，并且被购买的商品持有顾客。

 单向关联：类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如：顾客(Customer)拥有地址(Address)，则Customer类与Address类具有单向关联关系

 自关联：在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联

5、**继承**（is-a）：子类与父类的关系。

6、**实现**：实现指的是一个class类实现interface接口（可以是多个）的功能，实现是类与接口之间最常见的关系。

## 内存分配

基础类型的成员变量在栈内存中分配空间。形式参数也在栈中分配。

堆用来动态分配内存，在程序运行时，动态为对象分配内存。方法是一段静态的代码（此静态是指不变的代码），只用一份，执行的时候才占用内存。同一类的每个对象共享该类的方法。

调用的方法在栈中，方法执行结束后，从栈内清楚。为方法所分配的局部变量的内存也随之消失。

Java 对象的引用所有的地址不是绝对的物理地址，只是通过那个地址可以推出物理地址。？？？

## 对象与对象变量

一个对象变量并没有包含一个对象，而仅仅是引用一个对象。在Java种，任何一个对象变量的值都是存储在另一个地方的一个对象的引用。new操作符返回值也是一个引用。如果把一个变量的值赋给另一个变量，则他们是同一个对象的指针。所有的Java对象都存储在堆中。

### 隐式参数和显示参数

隐式参数是指未在方法是定义的，但的确又动态影响到程序运行的“参数”。一类就是this引用。另一类就是对象引用，类等。

显示参数是指在方法括号之间的参数，就是可以看见的参数。

### 其他

final修饰的基本类型表示数据不会被改变，修饰的引用类型表示对象的引用不会再指向别的地方，但是数据可以被改变。修饰的类不能被继承(类中的方法自动变为final类型，但是域不会变)，修饰的方法不能被重写。

如果将域定义为static，则所有此类的对象共享（对象中会有此域的拷贝）。

静态方法是一种不能向对象实施操作的方法，没有this参数，不能访问非静态域，因为其创建的时候还没有对象。

### 方法参数

形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。

实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。

值调用：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

引用调用：是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

Java总是按值调用的，方法不能修改传递给它的任何参数变量的内容。比如，如果传递的是一个基本类型的数据x，则在方法中会使用一个x的值的拷贝。方法结束后，x的值并没有变化。如果传递的是一个引用类型y，方法中会使用一个y值的引用。在方法中如果修改了该引用地址的值，则y所对应的值也发生了变化。如果在方法中重新new了一个新的对象，则不论如何操作，y的值不变。

![新建了一个对象](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5LgvDOib1a3eKd3R3xviafAIL3ticu8l5v14abgHO8ZjPpluULuic3fqYImpsNNeF1TB9ibCGSobKrIBUQ/640?)

![没有新建对象](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5LgvDOib1a3eKd3R3xviafAILurk5Da5jHibjayOkejTllTwXaOVniaJrgnBRcSyB1p2YGsJ71iarBSsgw/640?)

Java中参数的使用情况总结：

(1)方法不能修改一个基本数据类型的参数

(2)方法可以改变一个对象参数的状态

(3)方法不能让一个对象参数引用一个新的对象

## 对象构造

如果父类没有无参构造，则子类必须继承父类的一个或多个有参构造并在其中显示调用super()语句。

finalize方法在垃圾回收器清除对象之前调用。在实际应用中，不依赖此方法，因为很难知道这个方法在什么时候才能调用。

## 继承

继承已存在的类就是复用其方法和域。在此基础上，还可以添加一些新的方法和域，以满足需求。

反射是指在程序运行期间发现更多的类及其属性的能力。

“is-a”关系是继承的一个明显特征。

由一个公共超类派生出来的所有类的集合被称为继承层次。在继承层次中，从某个特定的类到期祖先的路径被称为该类的继承链。

所以Java中子类是可以继承父类中的所有的方法和属性值的。Java中的访问修饰符是用于限制类中的属性或者方法的访问权限的，与是否被继承并没有直接关系。子类不能直接访问超类的私有域，访问私有域需借助超类的公有接口或方法。调用父类的方法时，如需特别指定一下，需使用super关键字。

>super不是一个对象的引用，只是一个只是编译器调用超类方法的特殊关键字。可以使用super实现对超类构造器的调度，且super调用构造器的语句必须是子类构造器的第一条语句。

如果子类的构造器没有显式的调用超类的构造器，则将自动调用超类没有参数的构造器。如果超类没有不带参数的构造器，且子类的构造器中又没有显式的调用超类的其他构造器，则编译器会报错(为了避免操作对象时对象还未构建成功，需要this()和super()的调用在第一行实现,以此来创建对象，防止异常)。

>父类的构造器调用以及初始化过程一定在子类的前面

## 多态

一个对象变量可以指示多种实际类型的现象被称为多态（父类，子类），在运行中能够自动地选择调用那个方法的现象称为动态绑定。

Java实现多态有三个必要条件：继承、重写、向上转型。

在Java中有两种形式可以实现多态。继承和接口。

 对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。

在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。

### 向上转型和向下转型

**向上转型**：子类引用的对象转换为父类类型称为向上转型。通俗地说就是是将子类对象转为父类对象。此处父类对象可以是接口

**向下转型**：父类引用的对象转换为子类类型称为向下转型。

>转型需要注意的问题：

>向上转型时，父类指向子类引用对象会遗失除与父类对象共有的其他方法，也就是在转型过程中，子类的新有的方法都会遗失掉，在编译时，系统会提供找不到方法的错误。

总结：

1、父类引用可以指向子类对象，子类引用不能指向父类对象。

2、把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转型。

　　 如Father father = new Son();

3、把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型。

　　 如father就是一个指向子类对象的父类引用，把father赋给子类引用son 即Son son =（Son）father；

　　 其中father前面的（Son）必须添加，进行强制转换。

4、upcasting 会丢失子类特有的方法,但是子类overriding 父类的方法，子类方法**有效**

5、向上转型的作用，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样使代码变得简洁。体现了JAVA的抽象编程思想。

>覆盖只针对非静态方法（静态方法可以被继承，但是不能被重写，只能被隐藏），而隐藏是针对成员变量和静态方法的。这2者之间的区别是：覆盖受RTTI（Runtime type  identification）约束的，而隐藏却不受该约束。也就是说只有覆盖方法才会进行动态绑定，而隐藏是不会发生动态绑定的。在Java中，除了static方法和final方法，其他所有的方法都是动态绑定。所以，向上转型的时候，如果调用的是子类覆盖的父类的**非static和final**方法，则调用子类的方法。

## 方法调用

假设调用x.f(args)，x为C类的对象，args为String类型

1、编译器查看对象的声明类型和方法名。有可能存在多个名字为f，但是参数类型不一样的方法。编译器将会一一列举所有C类中名为f的方法和它超类中访问属性为public且名为f的方法。至此，编译器已获得所有可能被调用的候选方法。

2、接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法，这个过程被称为**重载解析**。由于允许类型转换（int可以转成double等），所以这个过程可能会很复杂。如果未找到此种方法，则编译器会报错。至此，编译器以获得需要调用的方法名字和参数类型。

3、如果是private方法、static方法、final方法或者构造器，那么编译器应该准确的知道应该调用那个方法，这种调用方式称为**静态绑定**。于此对应的是，调用的方法依赖隐式参数的实际类型，并且在运行时实现**动态绑定**。

4、当程序运行，且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最适合的那个类。此例中，如果C类中有f(String)方法则调用，否则去其超类中寻找，以此类推。

虚拟机预先为每个类创建了一个**方法表**，其中列出了所有方法的签名和实际调用的方法。这样一来，在方法调用的时候，虚拟机只要查找这个表就可以了。


## 枚举 enum

枚举其实是特殊的常量类，其构造方法默认强制为私有的。

枚举类型对象之间的值比较，可以使用==，直接来比较值，是否相等的。不要调用equals。

1. 所有的枚举类型都是Enum类的子类。 它们继承了这个类的许多方法。其中最有用的一个方法是toString()，这个方法能够返回枚举常量名。   toString()方法的逆方法是静态方法valueOf(Class, String). 例如 Light lt = (Light) Enum.valueOf(Light.class, "RED"); 将lt设置为 Light.RED。 每个枚举类型都有一个静态的values()方法，它将返回一个包含全部枚举值的数组。   ordinal()方法返回enum声明中枚举常量的位置，位置从0开始计数。例如  Light.GREEN.ordinal()返回1。   Enum类实现了Comparable接口，  int  compareTo( E other)  如果枚举常量在other之前，则返回一个负值； 如果this==other，则返回0；否则，返回正值。 枚举常量的出现次序在enum 声明中给出。（所以不能直接用<,>符号比较两个枚举值）

2. 可以创建一个enum类，把它看做一个普通的类。除了它不能继承其他类了。(java是单继承，它已经继承了Enum),

可以添加其他方法，覆盖它本身的方法

3. switch()参数可以使用enum了

4. values()方法是编译器插入到enum定义中的static方法，所以，当你将enum实例向上转型为父类Enum是，values()就不可访问了。解决办法：在Class中有一个getEnumConstants()方法，所以即便Enum接口中没有values()方法，我们仍然可以通过Class对象取得所有的enum实例

5. 无法从enum继承子类，如果需要扩展enum中的元素，在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组。达到将枚举元素进行分组。

6. 使用EnumSet代替标志。enum要求其成员都是唯一的，但是enum中不能删除添加元素。

7. EnumMap的key是enum，value是任何其他Object对象。

8. enum允许程序员为eunm实例编写方法。所以可以为每个enum实例赋予各自不同的行为。

9. 使用enum的职责链(Chain of Responsibility) .这个关系到设计模式的职责链模式。以多种不同的方法来解决一个问题。然后将他们链接在一起。当一个请求到来时，遍历这个链，直到链中的某个解决方案能够处理该请求。

## 反射

能够分析类能力的程序称为反射，就是在程序的运行过程中动态的加载类，获取类的变量及其方法。

获取Class对象的方式

1、X.getClass()

2、Class.forName(全限定名)

3、X.class

>Class对象实际表示的是一种类型，而这个类型未必是一种类。例如，int不是类，但是int.class是一个Class类型的对象

>Class实际上是一种泛型类

虚拟机为每个类管理一个Class对象，可以用==运算符实现两个类对象的比较。

**newInstance()**方法可以动态的创建一个类的实例。例如e.getClass().newInstance();其调用默认的构造器初始化新创建的对象，如果这个类没有默认的构造器，就会抛出异常。

将forName和newInstance结合起来，可以根据存储在字符串中的类名创建一个对象。

String s = "java.util,Random";

Object m = Class.fromName(s).newInstance();

>如果需要以这种方式向希望按名称创建的类的构造器提供参数， 就不要使用上面那条语句， 而必须使用 Constructor 类中的 newlnstance 方法。

在 java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、 方法和构造器。 这三个类都有一个叫做 getName 的方法， 用来返回项目的名称。Field 类有一个 getType 方法， 用来返回描述域所属类型的Class对象。Method 和 Constructor 类有能够报告参数类型的方法，Method 类还有一个可以报告返回类型的方法。这三个类还有一个叫做 getModifiers 的方法，它将返回一个整型数值，用不同的位开关描述public 和 static 这样的修饰符使用状况。另外， 还可以利用java.lang.refleCt 包中的 Modifier类的静态方法分析getModifiers 返回的整型数值。例如， 可以使用 Modifier类中的 isPublic、 issPrivate 或 isFinal判断方法或构造器是否是 public、private 或 final。 我们需要做的全部工作就是调用 Modifier类的相应方法，并对返回的整型数值进行分析，另外，还可以利用 Modifier.toString方法将修饰符打印出来。

Class类中的 getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的public 域、 方法和构造器数组， 其中包括超类的公有成员。Class 类的 getDeclareFields、getDeclareMethods 和 getDeclaredConstructors 方法将分别返回类中声明的全部域、 方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。

一般情况下我们使用反射获取一个对象的步骤：

获取类的 Class 对象实例

Class clz = Class.forName("com.zhenai.api.Apple");

根据 Class 对象实例获取 Constructor 对象

Constructor appleConstructor = clz.getConstructor();

使用 Constructor 对象的 newInstance 方法获取反射类对象

Object appleObj = appleConstructor.newInstance();

而如果要调用某一个方法，则需要经过下面的步骤：

获取方法的 Method 对象

Method setPriceMethod = clz.getMethod("setPrice", int.class);

利用 invoke 方法调用方法

setPriceMethod.invoke(appleObj, 14);

**总结**

1、Class类提供了四个public方法，用于获取某个类的构造方法。

Constructor getConstructor(Class[] params)     根据构造函数的参数，返回一个具体的具有public属性的构造函数

Constructor getConstructors()     返回所有具有public属性的构造函数数组

Constructor getDeclaredConstructor(Class[] params)     根据构造函数的参数，返回一个具体的构造函数（不分public和非public属性）

Constructor getDeclaredConstructors()    返回该类中所有的构造函数数组（不分public和非public属性）

2、四种获取成员方法的方法

Method getMethod(String name, Class[] params)    根据方法名和参数，返回一个具体的具有public属性的方法

Method[] getMethods()    返回所有具有public属性的方法数组

Method getDeclaredMethod(String name, Class[] params)    根据方法名和参数，返回一个具体的方法（不分public和非public属性）

Method[] getDeclaredMethods()    返回该类中的所有的方法数组（不分public和非public属性）

3、四种获取成员属性的方法

Field getField(String name)    根据变量名，返回一个具体的具有public属性的成员变量

Field[] getFields()    返回具有public属性的成员变量的数组

Field getDeclaredField(String name)    根据变量名，返回一个成员变量（不分public和非public属性）

Field[] getDelcaredField()    返回所有成员变量组成的数组（不分public和非public属性）

>**getDeclaredFields 和 getFields 的区别**

>getDeclaredFields()获得某个类的所有申明的字段，即包括public、private和proteced，但是不包括父类的申明字段。

>getFields()获得某个类的所有的公共（public）的字段，包括父类。

>反射机制的默认行为受限于 Java 的访问控制。然而， 如果一个 Java 程序没有受到安全管理器的控制， 就可以覆盖访问控制。 为了达到这个目的， 需要调用 Field、 Method 或Constructor 对象的 setAccessible 方法。

## 内部类

内部类是定义在另一个类中的类，使用内部类的主要原因有以下几点：

1、内部类方法可以访问访问该类定义所在的作用域中的数据

2、可以对一个包中的其他类隐藏起来

内部类既可以访问自身的数据域，也可以访问创建他的外围对象的数据域（静态内部类另算）。内部类对象总有一个隐式引用，指向创建它的外部类对象。这个引用在内部类的定义中时不可见的。外部类的引用在构造器中设置，编译器修改了内部类的所有构造器，添加了一个外部类引用的参数。

在内部类中，外部类的引用语法为：**OutClass.this**。比如引用一个外部类的变量outX，则其全部的引用语法为OutClas.this.outX。

>内部类中声明的所有的静态域必须是final。因为我们希望静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是final的，就不可能是唯一的。

>内部类访问外部类的局部变量时，会将外部类的局部变量拷贝一份作为自己的成员变量。所以，为了防止内部类中修改变量而无法影响外部类的变量值，外部类的局部变量会强制定义成final类型。这样，内部类和外部类都无法改变其值。
