## 1、 四大组件的运行状态

**Activity** 是一种展示型组件，用于向用户直接的展示一个界面，并且可以接收用户的输入信息从而进行交互。 Activity 组件的作用是展示一个界面并和用户交互，它扮演的是一种前台界面的角色。

**Service** 是一种计算型组件，它用于在后台做一些计算任务。它本身是运行在主线程中的，因此耗时操作的后台计算仍然要在单独的线程中完成。

**BroadcastReceiver** 是一种消息型组件，用于在不同组件乃至不同的应用之间传递消息。静态注册的广播在安装的时候就会被系统解析，此种形式的广播不需要应用启动就能收到相应的广播。动态注册的广播需要应用启动才能注册并接收广播。发送和接收过程的匹配是通过广播接收者的 <intent-filter> 来描述的。

**ContentProvider** 是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。它的内部需要实现增删改查这四种操作，在它内部维持着一份数据集合，这个数据集合即可以通过数据库来实现，也可以采用其他的方式来实现，比如 List 和 Map 。

## 2、Activity 的启动过程

Activity 的启动过程从 startActivity 方法开始，它有多个重载方式，但是最终都会调用 startActivityForResult 方法：

```java

public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
            @Nullable Bundle options) {
        if (mParent == null) {
            options = transferSpringboardActivityOptions(options);
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }
            if (requestCode >= 0) {
                // If this start is requesting a result, we can avoid making
                // the activity visible until the result is received.  Setting
                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
                // activity hidden during this time, to avoid flickering.
                // This can only be done when a result is requested because
                // that guarantees we will get information back when the
                // activity is finished, no matter what happens to it.
                mStartedActivity = true;
            }

            cancelInputsAndStartExitTransition(options);
            // TODO Consider clearing/flushing other event sources and events for child windows.
        } else {
            if (options != null) {
                mParent.startActivityFromChild(this, intent, requestCode, options);
            } else {
                // Note we want to go through this method for compatibility with
                // existing applications that may have overridden it.
                mParent.startActivityFromChild(this, intent, requestCode);
            }
        }
    }

```

我们只关注 mParent == null 这部分逻辑，在其中 mMainThread.getApplicationThread() 这个参数的类型是 ApplicationThread ，它是 ActivityThread 的一个内部类。我们接着看一下 mInstrumentation#execStartActivity 方法：

```java

public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        Uri referrer = target != null ? target.onProvideReferrer() : null;
        if (referrer != null) {
            intent.putExtra(Intent.EXTRA_REFERRER, referrer);
        }
        if (mActivityMonitors != null) {
            synchronized (mSync) {
                final int N = mActivityMonitors.size();
                for (int i=0; i<N; i++) {
                    final ActivityMonitor am = mActivityMonitors.get(i);
                    ActivityResult result = null;
                    if (am.ignoreMatchingSpecificIntents()) {
                        result = am.onStartActivity(intent);
                    }
                    if (result != null) {
                        am.mHits++;
                        return result;
                    } else if (am.match(who, null, intent)) {
                        am.mHits++;
                        if (am.isBlocking()) {
                            return requestCode >= 0 ? am.getResult() : null;
                        }
                        break;
                    }
                }
            }
        }
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return null;
    }

```

由此可以看出，启动 Activity 是由 ActivityManager.getService()#startActivity 来启动的。ActivityManager.getService() 返回了一个 IActivityManager 实例。而 IActivityManager 是一个接口，它的具体实现是 ActivityManagerService 。因此， Activity 的启动又转移到 AMS 中。在分析这个之前，我们看到 execStartActivity 方法中有一行 checkStartActivityResult(result, intent) 。我们跟进去看一下：

```java

public static void checkStartActivityResult(int res, Object intent) {
        if (!ActivityManager.isStartResultFatalError(res)) {
            return;
        }

        switch (res) {
            case ActivityManager.START_INTENT_NOT_RESOLVED:
            case ActivityManager.START_CLASS_NOT_FOUND:
                if (intent instanceof Intent && ((Intent)intent).getComponent() != null)
                    throw new ActivityNotFoundException(
                            "Unable to find explicit activity class "
                            + ((Intent)intent).getComponent().toShortString()
                            + "; have you declared this activity in your AndroidManifest.xml?");
                throw new ActivityNotFoundException(
                        "No Activity found to handle " + intent);
            case ActivityManager.START_PERMISSION_DENIED:
                throw new SecurityException("Not allowed to start activity "
                        + intent);
            case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
                throw new AndroidRuntimeException(
                        "FORWARD_RESULT_FLAG used while also requesting a result");
            case ActivityManager.START_NOT_ACTIVITY:
                throw new IllegalArgumentException(
                        "PendingIntent is not an activity");
            case ActivityManager.START_NOT_VOICE_COMPATIBLE:
                throw new SecurityException(
                        "Starting under voice control not allowed for: " + intent);
            case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:
                throw new IllegalStateException(
                        "Session calling startVoiceActivity does not match active session");
            case ActivityManager.START_VOICE_HIDDEN_SESSION:
                throw new IllegalStateException(
                        "Cannot start voice activity on a hidden session");
            case ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:
                throw new IllegalStateException(
                        "Session calling startAssistantActivity does not match active session");
            case ActivityManager.START_ASSISTANT_HIDDEN_SESSION:
                throw new IllegalStateException(
                        "Cannot start assistant activity on a hidden session");
            case ActivityManager.START_CANCELED:
                throw new AndroidRuntimeException("Activity could not be started for "
                        + intent);
            default:
                throw new AndroidRuntimeException("Unknown error code "
                        + res + " when starting " + intent);
        }
    }

```

我们可以看到，这个方法就是检查启动Activity的结果。

我们接着分析 AMS 的 startActivity 方法:

```java

@Override
public int startActivity(IApplicationThread caller, StringcallingPackage,
                          Intent intent, String resolvedType,
                          IBinder resultTo,String resultWho,
                          int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
         return mActivityTaskManager.startActivity(caller, callingPackage, intent, resolvedType,
                 resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions);
     }

```

由此可见，Activity 的启动又转移到 ActivityTaskManagerService 中，再调用 ActivityStartController 中的方法，再调用 ActivityStarter 中的方法。。。 最后调用到 ActivityThread 的 handleLaunchActivity 方法中：

```java

3396 if (localLOGV) Slog.v(
3397              TAG, "Handling launch of " + r);
3398
3399          // Initialize before creating the activity
3400          if (!ThreadedRenderer.sRendererDisabled
3401                  && (r.activityInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
3402              HardwareRenderer.preload();
3403          }
3404          WindowManagerGlobal.initialize();
3405
3406          // Hint the GraphicsEnvironment that an activity is launching on the process.
3407          GraphicsEnvironment.hintActivityLaunch();
3408
3409          final Activity a = performLaunchActivity(r, customIntent);
3410
3411          if (a != null) {
3412              r.createdConfig = new Configuration(mConfiguration);
3413              reportSizeConfigurations(r);
3414              if (!r.activity.mFinished && pendingActions != null) {
3415                  pendingActions.setOldState(r.state);
3416                  pendingActions.setRestoreInstanceState(true);
3417                  pendingActions.setCallOnPostCreate(true);
3418              }
3419          } else {
3420              // If there was an error, for any reason, tell the activity manager to stop us.
3421              try {
3422                  ActivityTaskManager.getService()
3423                          .finishActivity(r.token, Activity.RESULT_CANCELED, null,
3424                                  Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
3425              } catch (RemoteException ex) {
3426                  throw ex.rethrowFromSystemServer();
3427              }
3428          }

```

由此可见 performLaunchActivity 方法最终完成了 Activity 对象的创建过程。这个方法主要完成了以下几件事：

#### （1）、从ActivityClientRecord中获取待启动的Activity的组件信息：

```java

3160          ActivityInfo aInfo = r.activityInfo;
3161          if (r.packageInfo == null) {
3162              r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
3163                      Context.CONTEXT_INCLUDE_CODE);
3164          }
3165
3166          ComponentName component = r.intent.getComponent();
3167          if (component == null) {
3168              component = r.intent.resolveActivity(
3169                  mInitialApplication.getPackageManager());
3170              r.intent.setComponent(component);
3171          }
3172
3173          if (r.activityInfo.targetActivity != null) {
3174              component = new ComponentName(r.activityInfo.packageName,
3175                      r.activityInfo.targetActivity);
3176          }

```

#### （2）、通过 Instrumentation 的 newActivity 方法使用类加载器创建 Activity 对象：

```java

3179          Activity activity = null;
3180          try {
3181              java.lang.ClassLoader cl = appContext.getClassLoader();
3182              activity = mInstrumentation.newActivity(
3183                      cl, component.getClassName(), r.intent);
3184              StrictMode.incrementExpectedActivityCount(activity.getClass());
3185              r.intent.setExtrasClassLoader(cl);
3186              r.intent.prepareToEnterProcess();
3187              if (r.state != null) {
3188                  r.state.setClassLoader(cl);
3189              }
3190          } catch (Exception e) {
3191              if (!mInstrumentation.onException(activity, e)) {
3192                  throw new RuntimeException(
3193                      "Unable to instantiate activity " + component
3194                      + ": " + e.toString(), e);
3195              }
3196          }
3197

```

Instrumentation#newActivity:

```java

public Activity newActivity(ClassLoader cl, String className,
        Intent intent)
        throws InstantiationException, IllegalAccessException,
        ClassNotFoundException {
    return (Activity)cl.loadClass(className).newInstance();
}

```

#### （3）、通过 LoadedApk 的 makeApplication 方法来尝试创建 Application 对象

```java

Application app = r.packageInfo.makeApplication(false, mInstrumentation);

/*
*LoadedApk#makeApplication
**/

1194 public Application makeApplication(boolean forceDefaultAppClass,
1195              Instrumentation instrumentation) {
1196          if (mApplication != null) {
1197              return mApplication;
1198          }
1199
1200          Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "makeApplication");
1201
1202          Application app = null;
1203
1204          String appClass = mApplicationInfo.className;
1205          if (forceDefaultAppClass || (appClass == null)) {
1206              appClass = "android.app.Application";
1207          }
1208
1209          try {
1210              java.lang.ClassLoader cl = getClassLoader();
1211              if (!mPackageName.equals("android")) {
1212                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,
1213                          "initializeJavaContextClassLoader");
1214                  initializeJavaContextClassLoader();
1215                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
1216              }
1217              ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
1218              app = mActivityThread.mInstrumentation.newApplication(
1219                      cl, appClass, appContext);
1220              appContext.setOuterContext(app);
1221          } catch (Exception e) {
1222              if (!mActivityThread.mInstrumentation.onException(app, e)) {
1223                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
1224                  throw new RuntimeException(
1225                      "Unable to instantiate application " + appClass
1226                      + ": " + e.toString(), e);
1227              }
1228          }
1229          mActivityThread.mAllApplications.add(app);
1230          mApplication = app;
1231
1232          if (instrumentation != null) {
1233              try {
1234                  instrumentation.callApplicationOnCreate(app);
1235              } catch (Exception e) {
1236                  if (!instrumentation.onException(app, e)) {
1237                      Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
1238                      throw new RuntimeException(
1239                          "Unable to create application " + app.getClass().getName()
1240                          + ": " + e.toString(), e);
1241                  }
1242              }
1243          }
1244
1245          // Rewrite the R 'constants' for all library apks.
1246          SparseArray<String> packageIdentifiers = getAssets().getAssignedPackageIdentifiers();
1247          final int N = packageIdentifiers.size();
1248          for (int i = 0; i < N; i++) {
1249              final int id = packageIdentifiers.keyAt(i);
1250              if (id == 0x01 || id == 0x7f) {
1251                  continue;
1252              }
1253
1254              rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);
1255          }
1256
1257          Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
1258
1259          return app;
1260      }

```

从 makeApplication 的实现可以看出，如果 Application 已经创建过了，就不会再创建了，Application 对象的创建也是通过 Instrumentation 通过类加载器来创建的。

#### （4）、调用 ContextImpl 对象，并通过 Activity 的 attach 方法来完成一些数据的初始化

```java

3178          ContextImpl appContext = createBaseContextForActivity(r);
3210                  CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
3211                  Configuration config = new Configuration(mCompatConfiguration);
3212                  if (r.overrideConfig != null) {
3213                      config.updateFrom(r.overrideConfig);
3214                  }
3215                  if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
3216                          + r.activityInfo.name + " with config " + config);
3217                  Window window = null;
3218                  if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
3219                      window = r.mPendingRemoveWindow;
3220                      r.mPendingRemoveWindow = null;
3221                      r.mPendingRemoveWindowManager = null;
3222                  }
3223                  appContext.setOuterContext(activity);
3224                  activity.attach(appContext, this, getInstrumentation(), r.token,
3225                          r.ident, app, r.intent, r.activityInfo, title, r.parent,
3226                          r.embeddedID, r.lastNonConfigurationInstances, config,
3227                          r.referrer, r.voiceInteractor, window, r.configCallback,
3228                          r.assistToken);

```

ContextImpl 是一个很重要的数据结构，它是Context 的具体实现。ContextImpl 是通过 Activity 的 attach 方法和 Activity 建立联系的，除此之外，在 attach 方法中， Activity 还完成了 Window 的创建并建立自己和 Window 的联系，这样 Window 接收到外部输入事件后就可以将事件传递给Activity。

#### （5）、调用 Activity 的 onCreate 方法

```java

 mInstrumentation.callActivityOnCreate(activity, r.state);

```

由于 Activity 的 onCreate 方法已经被调用，这也意味着 Activity 已经完成了整个启动过程。
