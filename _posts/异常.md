## 什么是异常

异常（exception）是指程序在运行过程中，出现了意外的事件，使得程序没有按我们预期正常执行。出现这种情况，可能是我们使用了空的引用、文件读写失败或者是数组角标越界。程序在运行期间会发生什么错误我们无法预料，可是我们也不能放任不管，不然程序会终止甚至导致系统奔溃。可是，在运行期间出现的问题，我们应该怎么处理？

来，我们一起了解一下Java的异常机制。

## 异常分类

Java中，异常对象都是派生于Throwable类的一个实例。

![异常的继承关系](https://images2015.cnblogs.com/blog/936870/201707/936870-20170709120346087-1351539391.png)

由图可以看出，异常分为两类，Error和Exception。

Error，描述了Java运行时的内部错误和资源耗尽错误，比如OutOfMemoryError,代表了JVM本身的错误。错误不能被程序员通过代码处理。

Exception分为两个分支：checked exception和unchecked exception。

unchecked exception（非检查异常：RuntimeException）：对于这类异常，编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。

checked exception（检查异常）：比如IOException和SQLException等。Java编译器强制要求对这类异常进行捕获处理，否则，无法通过编译，比如说IOException。

## 捕获异常

要想捕获异常，需要使用**try/catch**语句，在try语句块中，包含可能抛出异常的代码块。在catch语句中，捕获并处理异常。现在举个小栗子🌰。

```
 try {
            File file = new File("test");
            if(!file.exists())
                file.createNewFile();
        } catch (IOException e) {
            // do something
        }
```

在这段代码中，try语句块中抛出了一个在catch语句中说明的异常(IOException)，那么，程序将跳过try语句块的其他代码，执行catch子句中的处理器代码。其他情况，如果try中没有抛出异常，则程序跳过catch语句。如果方法中抛出了一个在catch子句中没有声明的异常，则方法会立刻退出。

### 捕获多个异常

在一个try中使用多个catch语句可以捕获多个异常。也可以在catch语句中使用（X|Y）来统一处理多个异常。不过要注意，排在前面的异常尽量与排在后面的异常无关或者是其子类。比如：

```
 try {
            File file = new File("test");
            if(!file.exists())
                file.createNewFile();
        } catch (FileNotFoundException e) {
           // do something
        }
        } catch (IOException e) {
            // do something
        }
```

如果IOException放在FileNotFoundException前面，由于catch语句是顺序执行，而且FileNotFoundException是IOException的子类，所以FileNotFoundException发生时会被IOException捕获，因此catch中的FileNotFoundException语句块不会被执行到。

### finally语句

Java中，使用try/catch/finally组合语句可以处理很多的事情。三者的执行顺序为try-catch-finally。

如果不发生异常，catch块不会执行。不管是否发生异常，finally语句都被执行。

>出现以下几种情况的时候，finally也不执行：

>1、finally中发生了异常

>2、在前面的代码中使用System.exit()退出了程序，或者关闭了CPU。

>3、语句块所在的线程停止执行。

现在，我们再看一个小例子

```
    try {
            File file = new File("test");
            if(!file.exists())
                file.createNewFile();
        } catch (IOException e) {
            // do something
        }finally {

           // do something
           //在finally中，可以释放资源

        }
```

注意，finally子句包含 return 语句时，将会出现一种意想不到的结果。 假设利用return语句从try语句块中退出，在方法返回前finally 子句的内容将被执行。如果finally子句中也有一个return语句，这个返回值将会覆盖原始的返回值。finally中的return会抑制（消灭）前面try或者catch块中的异常。

### 抛出异常

除了处理异常，Java还支持抛出异常，就是当异常发生了，就把这个异常抛出去。此时需要用到两个关键字，**throws**和**throw**。

throws用在方法的首部，放在方法后面。例如：

```
public void createFile(String messge) throws IOException {

        File file = new File("test");
        if (!file.exists())
            file.createNewFile();

    }
```

而throw用在方法的内部,比如：

```
public int getItemByIndex(int index, List<Integer> list) {
        if (index < 0 || index >= list.size())
            throw new ArrayIndexOutOfBoundsException("数组角标越界");
        return list.get(index);
    }
```

要注意，抛出的异常不能是Error及其继承类，因为任何代码都具有抛出那些异常的可能性，我们对其没有控制能力。同样，如果声明的异常是从RuntimeException继承的非检查异常，那么我们需要用try-catch语句处理，或者让调用者去处理。因为这些问题在我们控制之下，我们应该修正错误，而不是抛出错误。

>子类覆盖超类的方法，子类方法中不能抛出比父类更大的异常。如果出现了比父类大的异常，子类必须捕获并处理。这是为了支持多态

### 再次抛出异常与异常链

异常链是一种面向对象编程技术，指将捕获的异常包装进一个新的异常中并重新抛出的异常处理方式。原异常被保存为新异常的一个属性（比如cause）。这样做的意义是一个方法应该抛出定义在相同的抽象层次上的异常，但不会丢弃更低层次的信息。

在catch子句中，可以抛出一个异常。这样做的目的是改变异常类型。比如：


```
try{
//出现异常的代码
}
catch (SQLException e){
Throwable se = new ServletException ("database error")；
se.initCause(e);
throw se;
}
```
initCause()的作用是包装原始的异常，当想要知道底层发生了什么异常的时候调用getCause()就能获得原始异常。

当捕获到异常时，可以使用以下语句重新获得原始的异常

Throwable e = se.getCause();

## 创建异常类

自定义的异常类，要派生于Exception或者其子类。定义的类应该包含如下的构造函数：

1、一个无参构造函数

2、一个带有String参数的构造函数，并传递给父类的构造函数。

3、一个带有String参数和Throwable参数，并都传递给父类构造函数

4、一个带有Throwable 参数的构造函数，并传递给父类的构造函数

我们写一下：

```
public class MyException extends Exception {

    public MyException() {
        super();
    }

    public MyException(String message) {
        super(message);
    }

    public MyException(String message, Throwable cause) {
        super(message, cause);
    }

    public MyException(Throwable cause) {
        super(cause);
    }

}
```
这样我们就定义好了一个自己的异常类。使用方式跟使用其他的异常类一样，这里就不做描述了。
