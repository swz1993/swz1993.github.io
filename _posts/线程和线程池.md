## 1、 Android 中的线程形态

#### 1.1、 AsyncTask

AsyncTask 在 Android 1.6 以前是串行执行任务，在 1.6 之后是用线程池处理并行任务，后来在 3.0 ，为了避免 AsyncTask 带来的并发失误，又采用一个线程来串行执行任务。但是，3.0 之后，我们可以用 AsyncTask#executeOnExecutor 来并行执行任务。

AsyncTask 封装了 Handler 和 Thread ，它是一个抽象的泛型类，AsyncTask 中有两个线程池和一个 Handler。一个线程池用来执行任务，另一个线程池用于任务排队。Handler 用于将执行环境从线程池切换到主线程。

其中线程池的规格为：

+ 核心线程数等于 CPU 核心数 + 1
+ 线程池的最大线程数等于 CPU 核心数的 2 倍 + 1
+ 核心线程无超时机制，非核心线程在闲置时的超时时间是 1 秒
+ 任务队列的容量为 128

#### 1.2、HandlerThread

继承了 Thread ，是一个可以使用 Handler 的Thread，它的实现就是在 run 方法中通过 Looper.prepare() 来创建消息队列，并且通过 Looper.loop() 来开启消息循环，这样在实际的使用中就允许在 HandlerThread 中创建 Handler 了。

#### 1.3、IntentService

封装了 HandlerThread 和 Handler，它被第一次启动的时候，会调用 onCreate 方法，在其中会创建一个 HandlerThread ，然后使用它的 Looper 来构造一个 Handler 对象 mServiceHandler ，这样通过 mServiceHandler 发送的消息最终都会在 HandlerThread 中执行。mServiceHandler 收到消息后，会将 Intent 对象传递给 onHandlerIntent 方法去处理。onHandlerIntent 方法结束后，IntentService 会使用 stopSelf(int startId) 方法来尝试停止服务（等待所有消息都处理完再停止）。

## 2、Android 中的线程池

线程池的优点：

+ 重用线程池中的线程，避免因为线程的创建和销毁而带来的性能的开销
+ 有效的控制线程的并发数，避免大量线程之间因互相抢占系统资源而导致的阻塞现象
+ 能够对线程进行简单的管理

#### 2.1、ThreadPoolExecutor

ThreadPoolExecutor 是线程池的真正实现，我们先看一下它构造函数中各个参数的的意义：

```java

public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }

```

+ corePoolSize：线程池的核心线程数，默认情况下会一直在线程池中存活，即时它们处于闲置状态。但是如果将 ThreadPoolExecutor 的 allowCoreThreadTineOut 属性设置为 true ，那么它们就会受到 keepAliveTime 的制约，如果等待的时间超出 keepAliveTime 所指定的时间，核心线程就会被终止
+ maximumPoolSize：线程池所能容纳的最大线程数，当活动线程到达这个值后，后续新的任务会被阻塞
+ keepAliveTime：线程闲置时的超时时长，超过这个时长，非核心线程（以及设置了属性的核心线程）就会被回收
+ unit：指定 keepAliveTime 的时间单位，是个枚举
+ workQueue：线程中的任务队列，通过线程池的 excute 方法提交的 Runnable 对象会存储在这个参数中
+ threadFactory：线程工厂，为线程池提供创建新线程的功能

#### 2.2、线程池的分类

以 newXXX 的方式创建以下线程

###### 2.2.1、FixeThreadPool

它是一种线程固定的线程池，只有核心线程且核心线程不会被回收，任务队列也没有大小限制。这意味着它能更快的响应外界的请求。

###### 2.2.2、CachedThreadPool

只有非核心线程，且线程池大小为Integer.MAX_VALUE。线程有超时机制，时间为60s，这个线程适合执行大量且耗时较少的任务

###### 2.2.3、ScheduledThreadPool

核心线程数是固定的(需要传入参数)，而非核心线程是不固定的，且非核心线程闲置时会被立即回收。这类线程池主要是用来执行定时任务和具有固定周期的重复任务

###### 2.2.4、 SingleThreadExecutor

只有一个核心线程，他确保所有的任务都在同一个线程中执按顺序执行
